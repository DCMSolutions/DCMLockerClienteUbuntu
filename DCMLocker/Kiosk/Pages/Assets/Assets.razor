@page "/assets"

@implements IAsyncDisposable
@inject IJSRuntime JS


<div class="container kiosk-full">
    @if (_screen == Screen.Select)
    {
        <div class="select-layout">
            <div>
                <div class="select-hero @(string.IsNullOrEmpty(_rfid) ? "image" : "blank")"></div>

                <div class="select-message">
                    @if (string.IsNullOrEmpty(_rfid))
                    {
                        <span>Acerque la tarjeta al lector para comenzar a operar</span>
                    }
                    else
                    {
                        <span>Bienvenido/a</span>
                    }
                </div>
            </div>

            <!-- Bottom: acciones -->
            <div class="select-bottom">
                <h6>Seleccione una opción</h6>
                <div class="select-actions">
                    <!-- Ingresar ≡ Devolución -->
                    <button class="btn btn-primary option-btn @(IsSelected(AssetsAccion.Devolucion) ? "is-selected" : "")"
                            @onclick="() => SelectAccion(AssetsAccion.Devolucion)">
                        Ingresar
                    </button>

                    <!-- Retirar ≡ Retiro -->
                    <button class="btn btn-primary option-btn @(IsSelected(AssetsAccion.Retiro) ? "is-selected" : "")"
                            @onclick="() => SelectAccion(AssetsAccion.Retiro)">
                        Retirar
                    </button>
                </div>
            </div>
        </div>

        <button class="hidden-admin-trigger" title=""
                @onclick="() => _screen = Screen.SecretPin"
                tabindex="-1"></button>
    }
    else if (_screen == Screen.FueraServicio)
    {
        <div class="oos-screen">
            <button class="hidden-admin-trigger" title=""
                    @onclick="() => _screen = Screen.SecretPin"
                    tabindex="-1"></button>

            <div class="oos-content text-center">
                <div class="oos-icon">⚠️</div>
                <div class="oos-title">Temporalmente fuera de servicio</div>

                @if (_errorCode != LockerErrorCode.None)
                {
                    <div class="oos-code">
                        Código de error: @GetErrorCodeNumber() - @GetErrorCodeDescription()
                    </div>
                }
            </div>
        </div>
    }
    else if (_screen == Screen.PuertasAbiertas)
    {
        <div class="oos-screen puertas-screen">
            <button class="hidden-admin-trigger" title=""
                    @onclick="() => _screen = Screen.SecretPin"
                    tabindex="-1"></button>

            <div class="oos-content text-center">
                <div class="oos-icon">⚠️</div>
                <div class="oos-title">Puertas abiertas</div>

                @if (_boxEnVerificacion != null)
                {
                    <div class="oos-code">
                        La puerta @_boxEnVerificacion está abierta. Por favor, ciérrela para continuar.
                    </div>
                }

                @if (_puertasAbiertas.Count > 0)
                {
                    <div class="mt-3">
                        <div>Puertas actualmente abiertas:</div>
                        <div class="puertas-list mt-2">
                            @foreach (var id in _puertasAbiertas)
                            {
                                <span class="puerta-chip">Box @id</span>
                            }
                        </div>
                    </div>
                }
            </div>
        </div>
    }

    else if (_screen == Screen.SecretPin)
    {
        <div class="kiosk-center text-center">
            <!-- Título grande como en el resto -->
            <div class="select-message mb-2">Acceso</div>

            <!-- Dots con altura fija para que no se mueva el teclado -->
            <div class="pin-dots fixed mb-4">@GetPinDots()</div>

            <!-- Teclado en grilla (3x4) con celdas iguales -->
            <div class="keypad-grid">
                @foreach (var key in new[] { "1", "2", "3", "4", "5", "6", "7", "8", "9", "C", "0", "←" })
                {
                    <button class="btn btn-outline-secondary key-btn" @onclick="@(() => OnKey(key))">@key</button>
                }
            </div>

            <!-- Botones grandes y consistentes -->
            <div class="select-actions mt-3">
                <button class="btn btn-primary option-btn"
                        disabled="@(_pinInput.Length == 0)"
                        @onclick="SubmitPin">
                    Ingresar
                </button>
                <button class="btn btn-cancel option-btn" @onclick="PinCancel">Cancelar</button>
            </div>
        </div>
    }
    else if (_screen == Screen.Loading)
    {
        <div class="kiosk-center text-center">
            <div class="spinner-border text-primary mb-3" role="status"><span class="sr-only">Cargando...</span></div>
            <div class="text-muted">@_loadingText</div>
        </div>
    }
    else if (_screen == Screen.ChooseAsset)
    {
        <div class="kiosk-up">
            <div class="mb-2">
                <div class="select-message">
                    Bienvenido/a @(_employeeName?.Length > 0 ? _employeeName : "")
                </div>
                <div class="select-bottom">
                    <h6>Seleccione activo</h6>
                </div>
            </div>

            @if (_assets.Count == 0)
            {
                <div class="text-center text-muted">No hay assets disponibles para retiro.</div>
                <div class="text-center mt-4">
                    <button class="btn btn-cancel" @onclick="Reset">Cancelar</button>
                </div>
            }
            else
            {
                <!-- Card scrolleable: mantiene fijo el header y la botonera -->
                <div class="card scroll-card shadow-sm">
                    <div class="card-body p-3">
                        <div class="row justify-content-center">
                            @foreach (var a in _assets)
                            {
                                var isSel = _selectedAsset?.IdAsset == a.IdAsset;
                                <div class="col-12 col-md-6 col-xl-5 mb-3">
                                    <div class="card asset-card compact shadow-sm @AssetCardClasses(a, isSel)"
                                         @onclick="@(() => SelectAsset(a))">
                                        <div class="card-body">
                                            <div class="asset-name">@a.NombreAsset</div>
                                            <div class="asset-meta @(isSel ? "text-white-50" : "text-muted")">
                                                Box: @a.IdBox
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            }
                        </div>
                    </div>
                </div>

                <!-- Botonera grande y consistente -->
                <div class="select-bottom mt-3">
                    <div class="select-actions">
                        <button class="btn btn-primary option-btn"
                                disabled="@(_selectedAsset == null)"
                                @onclick="GoConfirmRetiro">
                            Continuar
                        </button>
                        <button class="btn btn-cancel option-btn" @onclick="Reset">Cancelar</button>
                    </div>
                </div>
            }
        </div>
    }
    else if (_screen == Screen.ScanQr)
    {
        <div class="select-layout">
            <!-- Top: imagen grande + mensaje -->
            <div>
                <div class="select-hero" style="background-image:url('/img/7-rfid-tarjeta.png')"></div>

                <div class="select-message">
                    Acerque el TAG del activo al lector
                </div>
            </div>

            <!-- Bottom: solo cancelar -->
            <div class="text-center">
                <button class="btn btn-cancel" @onclick="Reset">Cancelar</button>
            </div>
        </div>
    }
    else if (_screen == Screen.DevolucionSetEstado)
    {
        <div class="kiosk-up">

            <!-- Info del activo con la misma forma que la lista -->
            <div class="row justify-content-center">
                <div class="col-12 col-lg-10 col-xl-9 mb-3">
                    <div class="card asset-card shadow-sm border-secondary" style="cursor: default;">
                        <div class="card-body text-center">
                            <h5 class="mb-2">@_selectedAsset?.NombreAsset</h5>
                            <div class="small text-muted">
                                ID: @_selectedAsset?.IdAsset &nbsp;|&nbsp; Box: @_selectedAsset?.IdBox
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Título grande -->
            <div class="select-message mb-3 text-center">
                Seleccione en qué estado se encuentra el activo
            </div>

            <!-- Opciones (auto-avanza) -->
            <div class="row justify-content-center">
                <div class="col-sm-6 col-md-5 col-lg-4 mb-4">
                    <div class="card state-card shadow-sm @(_devolEstado == AssetsEstado.Funcional ? "selected" : "border-secondary")"
                         @onclick="() => SelectEstadoAndProceed(AssetsEstado.Funcional)">
                        <div class="card-body text-center"><h5>Bueno</h5></div>
                    </div>
                </div>

                <div class="col-sm-6 col-md-5 col-lg-4 mb-4">
                    <div class="card state-card shadow-sm @(_devolEstado == AssetsEstado.Defectuoso ? "selected" : "border-secondary")"
                         @onclick="() => SelectEstadoAndProceed(AssetsEstado.Defectuoso)">
                        <div class="card-body text-center"><h5>Defectuoso</h5></div>
                    </div>
                </div>
            </div>

            <!-- Cancelar (discreto y unificado) -->
            <div class="text-center mt-3">
                <button class="btn btn-cancel" @onclick="Reset">Cancelar</button>
            </div>
        </div>
    }
    else if (_screen == Screen.Result)
    {
        <div class="select-layout">
            <div class="text-center">
                <div class="select-hero" style="background-image:url('@_resImage')"></div>
                <div class="select-message">@_resTitle</div>

                @if (!string.IsNullOrWhiteSpace(_resSubtitle))
                {
                    <div class="result-sub">@_resSubtitle</div>
                }

                <div class="countdown-wrap mt-3"
                     @key="_countdownKey"
                     style="--duration:@($"{_countdownTotalMs}ms")">
                    <div class="countdown-bar">
                        <span class="countdown-bar-fill"></span>
                    </div>
                    <div class="countdown-text text-muted mt-2">
                        Volviendo en <strong>@Math.Max(1, (int)Math.Ceiling(_countdownRemainingMs / 1000.0))</strong> s
                    </div>
                </div>

            </div>

            <div></div>
        </div>
    }
    else if (_screen == Screen.Admin)
    {
        <div class="kiosk-up">
            <div class="text-center mb-3">
                <h4 class="m-0">Administrador</h4>
            </div>

            <div class="row justify-content-center">
                <div class="col-12 col-lg-10">
                    <div class="card shadow-sm border-secondary mb-4">
                        <div class="card-body">
                            <div class="d-flex flex-wrap justify-content-center mb-3">
                                <button class="btn btn-danger m-2" @onclick="AdminShutdown" disabled="@_adminBusy">Apagar</button>
                                <button class="btn btn-warning m-2" @onclick="AdminReset" disabled="@_adminBusy">Reiniciar</button>
                                <button class="btn btn-success m-2" @onclick="AdminUpdate" disabled="@_adminBusy">Actualizar</button>
                                <button class="btn btn-primary m-2" @onclick="AdminResetNavegador" disabled="@_adminBusy">Reiniciar navegador</button>
                                <button class="btn btn-outline-secondary m-2" @onclick="AdminBack" disabled="@_adminBusy">Volver</button>
                            </div>

                            @if (!string.IsNullOrEmpty(_adminMsg))
                            {
                                <div class="alert alert-info py-2 mb-3">@_adminMsg</div>
                            }

                            <div class="row text-center">
                                <div class="col-12 col-md-4 mb-3">
                                    <div class="border rounded p-3 h-100">
                                        <div class="text-muted small">Versión</div>
                                        <div class="lead">@(_adminVersion ?? "—")</div>
                                    </div>
                                </div>
                                <div class="col-12 col-md-4 mb-3">
                                    <div class="border rounded p-3 h-100">
                                        <div class="text-muted small">Fecha</div>
                                        <div class="lead">@(_adminFecha ?? "—")</div>
                                    </div>
                                </div>
                                <div class="col-12 col-md-4 mb-3">
                                    <div class="border rounded p-3 h-100">
                                        <div class="text-muted small">IPs</div>
                                        @if (_adminIPs.Count == 0)
                                        {
                                            <div class="lead">—</div>
                                        }
                                        else
                                        {
                                            <ul class="list-unstyled m-0">
                                                @foreach (var ip in _adminIPs)
                                                {
                                                    <li class="lead">@ip</li>
                                                }
                                            </ul>
                                        }
                                    </div>
                                </div>
                            </div>

                            @if (_adminBusy)
                            {
                                <div class="text-center mt-3">
                                    <div class="spinner-border text-primary" role="status"><span class="sr-only">Cargando…</span></div>
                                </div>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }

</div>

@code {
    enum Screen { Select, Loading, ChooseAsset, ScanQr, DevolucionSetEstado, Result, SecretPin, Admin, FueraServicio, PuertasAbiertas }
    Screen _screen = Screen.Select;


    // entrada
    private string? _rfid;
    private AssetsAccion? _accion;


    // respuesta SendRequest
    private string _employeeName = "";
    private List<ShortAsset> _assets = new();
    private ShortAsset? _selectedAsset;

    // devolución: estado del activo
    private AssetsEstado? _devolEstado;
    private AssetsEstado? _devolEstadoElegido;

    // Resultado UI (éxito / error)
    private string _resTitle = "";
    private string? _resSubtitle;
    private string _resImage = "";

    // Config unificada (ms)
    private Config2 _cfg2 = new Config2 { Modo = "assets" };

    // Countdown (ms)
    private int _countdownTotalMs = 5000;
    private int _countdownRemainingMs = 5000;
    private string _countdownKey = Guid.NewGuid().ToString("N");

    // Polling puertas abiertas
    private int _puertasPollMs = 1000;


    // resultado final
    private CancellationTokenSource? _countdownCts;
    private bool _sending;
    private string _loadingText = "Enviando solicitud…";

    // JS / SignalR
    private IJSObjectReference? _scannerModule;
    private DotNetObjectReference<Assets>? _selfRef;
    private HubConnection? _hub;            // RFID
    private HubConnection? QRhubConnection; // QR
    // Hub de estado (STATUS + cerraduras)
    private HubConnection? _statusHub;

    // para el pin para la pantalla de seguridad
    private string _pinInput = "";
    private const int _pinMax = 8;
    private const string _adminPin = "39426641";

    // --- Admin ---
    private bool _adminBusy;
    private string? _adminVersion;
    private string? _adminFecha;
    private List<string> _adminIPs = new();
    private string? _adminMsg;

    // lo de fuera de servicio
    enum LockerErrorCode
    {
        None = 0,
        Cerraduras = 1,          // 01
        Servidor = 2,            // 02
        RedEthernet = 3,         // 03
        Internet = 4,            // 04
        CerradurasYInternet = 5, // 05
        Inesperado = 99          // 99
    }
    private LockerErrorCode _errorCode = LockerErrorCode.None;
    private bool _cerradurasConectadas = true;
    private bool _serverOk = true;
    private bool _ethernetOk = true;
    private bool _internetOk = true;

    //lo de chequeo de sensores
    private int? _boxEnVerificacion;
    private CancellationTokenSource? _puertasAbiertasCts;
    private List<int> _puertasAbiertas = new();

    // --- init ---
    protected override async Task OnInitializedAsync()
    {
        await LoadAssetsTimingAsync();

        // Hub de QR
        QRhubConnection = new HubConnectionBuilder()
            .WithUrl(Nav.ToAbsoluteUri("/QRReaderHub"))
            .WithAutomaticReconnect()
            .Build();

        QRhubConnection.On<string>("ReceiveToken", (string text) =>
        {
            if (_screen != Screen.ScanQr) return;      // solo escuchamos durante el escaneo de QR
            HandleQrScan(text);
        });

        // Hub de RFID
        _hub = new HubConnectionBuilder()
            .WithUrl(Nav.ToAbsoluteUri("/RFIDReaderHub"))
            .WithAutomaticReconnect()
            .Build();

        _hub.On<string>("ReceiveRFID", token =>
        {
            Console.WriteLine(token);
            if (_screen != Screen.Select) return;
            SetRfid(token);
        });

        await _hub.StartAsync();
        await QRhubConnection.StartAsync();

        await InitializeStatusAsync();

        // 2) Hub de estado (ServerHub: STATUS + UpdateCerraduras)
        //    Ajustá "/serverhub" si tu hub está mapeado con otro path.
        _statusHub = new HubConnectionBuilder()
            .WithUrl(Nav.ToAbsoluteUri("/ServerHub"))
            .WithAutomaticReconnect()
            .Build();

        _statusHub.On<string>("STATUS", OnStatusChanged);
        _statusHub.On<string>("CERRADURAS", OnCerradurasChanged);

        await _statusHub.StartAsync();

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;
        _scannerModule = await JS.InvokeAsync<IJSObjectReference>("import", "./js/LectorRFID.js");
        _selfRef = DotNetObjectReference.Create(this);
        await _scannerModule.InvokeVoidAsync("attach", _selfRef, new { acceptTabAsEnter = true });
    }

    private async Task LoadAssetsTimingAsync()
    {
        _cfg2 = await Cliente.GetConfigAsync();

        // usamos DelayStatus como polling (ya es ms)
        _puertasPollMs = Math.Max(200, _cfg2.DelayStatus);
    }


    [JSInvokable]
    public async Task OnScanEnter(string text)
    {
        if (_screen != Screen.Select) return;
        SetRfid(text);

        if (_hub is not null && _hub.State == HubConnectionState.Connected)
            await _hub.SendAsync("SendToken", text);
    }

    private void SetRfid(string token)
    {
        _rfid = token;
        _ = TryProceedAsync();
        StateHasChanged();
    }

    bool IsSelected(AssetsAccion a) => _accion == a;
    void SelectAccion(AssetsAccion a)
    {
        if (_accion == a)
        {
            // si toco la misma, deselecciono
            _accion = null;
            StateHasChanged();
            return;
        }

        _accion = a;
        _ = TryProceedAsync();
        StateHasChanged();
    }

    // --- paso 1: enviar solicitud y ramificar ---
    async Task TryProceedAsync()
    {
        if (_sending) return;
        if (string.IsNullOrWhiteSpace(_rfid) || _accion is null) return;

        _sending = true;
        _loadingText = "Enviando solicitud…";
        _screen = Screen.Loading;
        StateHasChanged();

        try
        {
            var req = new AssetsRequest { IdEmpleado = _rfid!, Accion = _accion.Value };
            var resp = await Cliente.SendRequest(req);

            _employeeName = resp?.NombreEmpleado ?? "";
            _assets = resp?.AssetsList ?? new List<ShortAsset>();

            if (string.IsNullOrWhiteSpace(_employeeName))
            {
                ShowError("Usuario no registrado",
                          "Por favor, comuníquese con el administrador. Gracias.",
                          _cfg2.TimeUsuarioNoRegistrado);
                return;
            }


            if (_accion == AssetsAccion.Retiro)
            {
                if (_assets.Count == 0)
                {
                    ShowError($"No hay activos disponibles para {_employeeName}",
                              null,
                              _cfg2.TimeNoHayActivosDisponibles);
                    return;
                }

                _selectedAsset = null;
                _screen = Screen.ChooseAsset;
            }
            else // Devolución
            {
                if (_assets.Count == 0)
                {
                    ShowError("No hay activos disponibles para devolución",
                              "Por favor, intente en otro momento. Gracias.",
                              _cfg2.TimeNoHayActivosDisponibles);
                    return;
                }

                _selectedAsset = null;
                _devolEstado = null;
                _screen = Screen.ScanQr; // esperar QR del activo
            }

        }
        catch (Exception ex)
        {
            ShowError("Error procesando la solicitud", "Por favor, intente nuevamente o comuníquese con el administrador.");
        }
        finally
        {
            _sending = false;
            StateHasChanged();
        }
    }

    // --- RETIRO ---
    void SelectAsset(ShortAsset a) => _selectedAsset = a;
    async Task GoConfirmRetiro()
    {
        if (_selectedAsset == null) return;
        await SendRetiro();
    }

    async Task SendRetiro()
    {
        if (_selectedAsset == null) return;
        _loadingText = "Procesando retiro…";
        _screen = Screen.Loading;
        StateHasChanged();

        try
        {
            var ret = await Cliente.OpenBoxByFisico(_selectedAsset.IdBox);

            // Si las cerraduras NO están conectadas, usamos el flujo viejo
            if (!_cerradurasConectadas)
            {
                var evt = new AssetsEventoLocker
                {
                    IdAsset = _selectedAsset.IdAsset,
                    IdEmpleado = _rfid!,
                    Evento = AssetsEvento.CheckOut,
                    FechaEvento = DateTime.Now
                };
                await Cliente.ReportEvento(evt);

                ShowSuccess($"Puerta {_selectedAsset.IdBox} abierta.",
                            "Por favor, al terminar cierre la puerta. Gracias",
                            _cfg2.TimeOperacionExitosa);
                return;
            }

            // Cerraduras conectadas → nuevo flujo con verificación
            _boxEnVerificacion = _selectedAsset.IdBox;

            ShowResult(
                    success: true,
                    title: $"Puerta {_selectedAsset.IdBox} abierta.",
                    subtitle: "Por favor, al terminar cierre la puerta. Gracias",
                    durationMs: _cfg2.TimeOperacionExitosa,
                    onFinished: async () => await VerificarDespuesDePuertaAbiertaAsync()
                );
        }
        catch
        {
            ShowError("Error al procesar retiro", "Por favor, intente nuevamente o comuníquese con el administrador.");
        }
    }

    private async Task VerificarDespuesDePuertaAbiertaAsync()
    {
        if (_selectedAsset == null || _boxEnVerificacion == null)
        {
            ShowError("Operación fallida", "No se pudo verificar el estado del box.");
            return;
        }

        if (!_cerradurasConectadas)
        {
            // Se desconectaron las cerraduras en el medio; la lógica de fuera de servicio se encarga
            return;
        }

        BoxStatusDto? status;
        try
        {
            status = await Cliente.GetBoxStatusPorId(_boxEnVerificacion.Value);
        }
        catch
        {
            ShowError("Operación fallida", "No se pudo obtener el estado del box.");
            return;
        }

        if (status == null)
        {
            ShowError("Operación fallida", "No se pudo encontrar el box.");
            return;
        }

        bool puertaCerrada = status.Puerta;   // true = cerrada
        bool ocupado = status.Ocupacion;      // true = algo adentro
        var accionActual = _accion ?? AssetsAccion.None;

        if (puertaCerrada)
        {
            if (accionActual == AssetsAccion.Retiro)
            {
                // RETIRO: éxito = puerta cerrada + box vacío
                if (!ocupado)
                {
                    await RegistrarYMostrarExitoFinalAsync();
                }
                else
                {
                    ShowError("Operación fallida", "El asset no fue retirado.");
                }
            }
            else if (accionActual == AssetsAccion.Devolucion)
            {
                // DEVOLUCIÓN: éxito = puerta cerrada + box ocupado
                if (ocupado)
                {
                    await RegistrarYMostrarExitoFinalAsync();
                }
                else
                {
                    ShowError("Operación fallida", "El asset no fue devuelto.");
                }
            }
            else
            {
                ShowError("Operación fallida", "Operación desconocida.");
            }
        }
        else
        {
            // Puerta abierta. Si no queremos detección, no bloqueamos.
            if (!_cfg2.DeteccionPuertasAbiertas)
            {
                await RegistrarYMostrarExitoFinalAsync();
                return;
            }

            await MostrarPantallaPuertasAbiertasYMonitorearAsync();
        }

    }


    private async Task MostrarPantallaPuertasAbiertasYMonitorearAsync()
    {
        _puertasAbiertasCts?.Cancel();
        _puertasAbiertasCts = new CancellationTokenSource();

        _screen = Screen.PuertasAbiertas;
        await InvokeAsync(StateHasChanged);

        _ = MonitorPuertasAbiertasAsync(_puertasAbiertasCts.Token);
    }

    private async Task MonitorPuertasAbiertasAsync(CancellationToken token)
    {
        while (!token.IsCancellationRequested)
        {
            if (!_cerradurasConectadas)
            {
                // Fuera de servicio se va a encargar
                return;
            }

            List<BoxPuertaDTO> estados;
            try
            {
                estados = await Cliente.GetAllBoxStatus();
            }
            catch
            {
                await InvokeAsync(() =>
                {
                    ShowError("Operación fallida", "No se pudo obtener el estado de las puertas.");
                });
                return;
            }

            var abiertas = estados
                .Where(b => !b.Puerta)   // false = abierta
                .Select(b => b.IdBox)
                .OrderBy(x => x)
                .ToList();

            await InvokeAsync(() =>
            {
                _puertasAbiertas = abiertas;
                StateHasChanged();
            });

            if (abiertas.Count == 0)
            {
                // Todas cerradas
                break;
            }

            try
            {
                await Task.Delay(_puertasPollMs, token);
            }
            catch
            {
                return;
            }
        }

        if (!token.IsCancellationRequested)
        {
            await InvokeAsync(async () =>
            {
                await VerificarBoxAlCerrarAsync();
            });
        }
    }

    private async Task VerificarBoxAlCerrarAsync()
    {
        if (_boxEnVerificacion == null || _selectedAsset == null)
        {
            ShowError("Operación fallida", "No se pudo verificar el estado del box.");
            return;
        }

        if (!_cerradurasConectadas)
        {
            return;
        }

        BoxStatusDto? status;
        try
        {
            status = await Cliente.GetBoxStatusPorId(_boxEnVerificacion.Value);
        }
        catch
        {
            ShowError("Operación fallida", "No se pudo obtener el estado del box.");
            return;
        }

        if (status == null)
        {
            ShowError("Operación fallida", "No se pudo encontrar el box.");
            return;
        }

        bool puertaCerrada = status.Puerta;
        bool ocupado = status.Ocupacion;
        var accionActual = _accion ?? AssetsAccion.None;

        if (!puertaCerrada)
        {
            // Sigue abierta por alguna razón → volvemos a la pantalla de puertas abiertas
            await MostrarPantallaPuertasAbiertasYMonitorearAsync();
            return;
        }

        if (accionActual == AssetsAccion.Retiro)
        {
            // RETIRO: éxito = cerrada + vacío
            if (!ocupado)
            {
                await RegistrarYMostrarExitoFinalAsync();
            }
            else
            {
                ShowError("Operación fallida", "El asset no fue retirado.");
            }
        }
        else if (accionActual == AssetsAccion.Devolucion)
        {
            // DEVOLUCIÓN: éxito = cerrada + ocupado
            if (ocupado)
            {
                await RegistrarYMostrarExitoFinalAsync();
            }
            else
            {
                ShowError("Operación fallida", "El asset no fue devuelto.");
            }
        }
        else
        {
            ShowError("Operación fallida", "Operación desconocida.");
        }
    }


    private async Task RegistrarYMostrarExitoFinalAsync()
    {
        if (_selectedAsset == null || string.IsNullOrWhiteSpace(_rfid))
        {
            ShowError("Operación fallida", "No se pudo registrar la operación.");
            return;
        }

        var accionActual = _accion ?? AssetsAccion.None;

        try
        {
            if (accionActual == AssetsAccion.Retiro)
            {
                var evt = new AssetsEventoLocker
                {
                    IdAsset = _selectedAsset.IdAsset,
                    IdEmpleado = _rfid!,
                    Evento = AssetsEvento.CheckOut,
                    FechaEvento = DateTime.Now
                };
                await Cliente.ReportEvento(evt);
            }
            else if (accionActual == AssetsAccion.Devolucion)
            {
                var evt = new AssetsEventoLocker
                {
                    IdAsset = _selectedAsset.IdAsset,
                    IdEmpleado = _rfid!,
                    Box = _selectedAsset.IdBox,
                    Evento = AssetsEvento.CheckIn,
                    EstadoNuevo = _devolEstadoElegido,
                    FechaEvento = DateTime.Now
                };
                await Cliente.ReportEvento(evt);
            }
            else
            {
                // operación desconocida → no mandamos evento
            }
        }
        catch
        {
            // En el futuro podés loguear; de cara al usuario la operación fue correcta
        }

        // Pantalla final de éxito (3s) y luego Reset (porque ShowSuccess llama a ShowResult)
        ShowSuccess("Operación exitosa");
    }



    string AssetStateClass(ShortAsset a)
    {
        // Rojo si Defectuoso; Amarillo si NO es Funcional ; (Funcional sin clase)
        return a.Estado == AssetsEstado.Defectuoso
            ? "asset-defectuoso"
            : (a.Estado == AssetsEstado.Funcional ? "" : "asset-warning");
    }

    string AssetCardClasses(ShortAsset a, bool isSel)
    {
        var state = AssetStateClass(a);
        return $"{(isSel ? "selected" : "border-secondary")} {state}".Trim();
    }

    // --- DEVOLUCIÓN ---
    void HandleQrScan(string text)
    {
        var code = text?.Trim();
        if (code.StartsWith("\\000026"))
            code = code.Substring(7);

        var match = _assets.FirstOrDefault(a => string.Equals(a.IdAsset, code, StringComparison.OrdinalIgnoreCase));

        if (match == null)
        {
            ShowError("Activo no registrado",
                      "Por favor, comuníquese con el administrador. Gracias.",
                      _cfg2.TimeActivoNoRegistrado);
            return;
        }

        if (match.IdBox == 0)
        {
            ShowError("No hay boxes disponibles",
                      "Por favor, intente en otro momento. Gracias.",
                      _cfg2.TimeNoHayBoxesDisponibles);
            return;
        }


        _selectedAsset = match;
        _devolEstado = null;
        _screen = Screen.DevolucionSetEstado;
        StateHasChanged();
    }

    async Task SelectEstadoAndProceed(AssetsEstado estado)
    {
        _devolEstado = estado;
        await ProceedDevolucion();
    }

    async Task ProceedDevolucion()
    {
        if (_selectedAsset == null) return;

        // Guardamos el estado elegido para usarlo luego al registrar el evento
        _devolEstadoElegido = _devolEstado;

        _loadingText = "Procesando devolución…";
        _screen = Screen.Loading;
        StateHasChanged();

        try
        {
            var ret = await Cliente.OpenBoxByFisico(_selectedAsset.IdBox);

            // Si las cerraduras NO están conectadas, usamos el flujo viejo
            if (!_cerradurasConectadas)
            {
                var evt = new AssetsEventoLocker
                {
                    IdAsset = _selectedAsset.IdAsset,
                    IdEmpleado = _rfid!,
                    Box = _selectedAsset.IdBox,
                    Evento = AssetsEvento.CheckIn,
                    EstadoNuevo = _devolEstadoElegido,
                    FechaEvento = DateTime.Now
                };
                await Cliente.ReportEvento(evt);

                ShowSuccess($"Puerta {_selectedAsset.IdBox} abierta.", "Por favor, al terminar cierre la puerta. Gracias");
                return;
            }

            // Cerraduras conectadas → nuevo flujo con verificación (igual que retiro)
            _boxEnVerificacion = _selectedAsset.IdBox;

            ShowResult(
                    success: true,
                    title: $"Puerta {_selectedAsset.IdBox} abierta.",
                    subtitle: "Por favor, al terminar cierre la puerta. Gracias",
                    durationMs: _cfg2.TimeOperacionExitosa,
                    onFinished: async () => await VerificarDespuesDePuertaAbiertaAsync()
                );


        }
        catch
        {
            ShowError("Error al procesar ingreso", "Por favor, intente nuevamente o comuníquese con el administrador.");
        }
    }

    void ShowDoorThenFinal(int box)
    {
        ShowResult(true,
            $"Puerta {box} abierta.",
            "Por favor, al terminar cierre la puerta. Gracias",
            _cfg2.TimeOperacionExitosa,
            onFinished: async () =>
            {
                ShowSuccess("Operación exitosa");
                await Task.CompletedTask;
            });
    }

    void ShowResult(bool success, string title, string? subtitle, int durationMs, Func<Task>? onFinished = null)
    {
        _resTitle = title;
        _resSubtitle = subtitle;
        _resImage = success ? "/img/tick.png" : "/img/cross.png";

        _screen = Screen.Result;

        _countdownTotalMs = Math.Max(500, durationMs);          // mínimo 0.5s para que se vea
        _countdownRemainingMs = _countdownTotalMs;
        _countdownKey = Guid.NewGuid().ToString("N");           // reinicia animación

        _countdownCts?.Cancel();
        _countdownCts = new CancellationTokenSource();

        _ = StartCountdownAsync(_countdownTotalMs, _countdownCts.Token, onFinished ?? (async () => Reset()));
        StateHasChanged();
    }

    void ShowSuccess(string title, string? subtitle = null, int? durationMs = null)
        => ShowResult(true, title, subtitle, durationMs ?? _cfg2.TimeOperacionExitosa);

    void ShowError(string title, string? subtitle = null, int? durationMs = null)
        => ShowResult(false, title, subtitle, durationMs ?? _cfg2.TimeOperacionCancelada);

    async Task StartCountdownAsync(int durationMs, CancellationToken token, Func<Task>? onFinished = null)
    {
        _countdownTotalMs = Math.Max(500, durationMs);
        _countdownRemainingMs = _countdownTotalMs;
        await InvokeAsync(StateHasChanged);

        // Actualizamos el número cada 200ms para que se vea más “vivo” (la barra ya es suave).
        const int tickMs = 200;

        while (_countdownRemainingMs > 0 && !token.IsCancellationRequested)
        {
            try { await Task.Delay(tickMs, token); }
            catch { break; }

            _countdownRemainingMs = Math.Max(0, _countdownRemainingMs - tickMs);
            await InvokeAsync(StateHasChanged);
        }

        if (!token.IsCancellationRequested)
        {
            if (onFinished != null) await onFinished();
            else Reset();
        }
    }



    void Reset()
    {
        _countdownCts?.Cancel();
        _puertasAbiertasCts?.Cancel();

        _rfid = null;
        _accion = null;
        _employeeName = "";
        _assets.Clear();
        _selectedAsset = null;
        _devolEstado = null;
        _devolEstadoElegido = null;
        _boxEnVerificacion = null;
        _puertasAbiertas.Clear();

        _screen = _errorCode == LockerErrorCode.None
            ? Screen.Select
            : Screen.FueraServicio;

        StateHasChanged();
    }



    // PANTALLA DE ID
    void PinAdd(string d)
    {
        if (_pinInput.Length < _pinMax)
            _pinInput += d;
    }

    void PinBackspace()
    {
        if (_pinInput.Length > 0)
            _pinInput = _pinInput[..^1];
    }

    void PinClear() => _pinInput = "";

    void PinCancel()
    {
        _pinInput = "";
        _screen = _errorCode == LockerErrorCode.None
            ? Screen.Select
            : Screen.FueraServicio;
    }


    async Task SubmitPin()
    {
        var pin = _pinInput;
        _pinInput = "";

        if (pin == _adminPin)
        {
            _screen = Screen.Admin;
            StateHasChanged();
            await LoadAdminAsync();
        }
        else
        {
            // PIN incorrecto → volver a la pantalla principal
            PinCancel();
        }
    }

    string GetPinDots() => new string('*', _pinInput.Length);

    void OnKey(string key)
    {
        if (key == "C") { PinClear(); return; }
        if (key == "←") { PinBackspace(); return; }
        PinAdd(key);
    }

    async Task LoadAdminAsync()
    {
        _adminBusy = true;
        _adminMsg = null;
        _adminVersion = null;
        _adminFecha = null;
        _adminIPs.Clear();
        StateHasChanged();

        try
        {
            _adminVersion = await Cliente.GetVersion();
            _adminFecha = await Cliente.GetFecha();
            var nets = await Cliente.System_GetIP(); // devuelve SystemNetwork[]
            if (nets != null)
                _adminIPs = nets
                    .Select(n => n?.IP)
                    .Where(ip => !string.IsNullOrWhiteSpace(ip))
                    .Distinct()
                    .ToList();
        }
        catch (Exception ex)
        {
            _adminMsg = $"ERROR: {ex.Message}";
        }
        finally
        {
            _adminBusy = false;
            StateHasChanged();
        }
    }

    async Task AdminShutdown()
    {
        if (_adminBusy) return;
        _adminBusy = true; _adminMsg = "Enviando apagado…"; StateHasChanged();
        try { await Cliente.System_Shutdown(); _adminMsg = "Comando de apagado enviado."; }
        catch (Exception ex) { _adminMsg = $"ERROR: {ex.Message}"; }
        finally { _adminBusy = false; StateHasChanged(); }
    }

    async Task AdminReset()
    {
        if (_adminBusy) return;
        _adminBusy = true; _adminMsg = "Enviando reinicio…"; StateHasChanged();
        try { await Cliente.System_Reset(); _adminMsg = "Comando de reinicio enviado."; }
        catch (Exception ex) { _adminMsg = $"ERROR: {ex.Message}"; }
        finally { _adminBusy = false; StateHasChanged(); }
    }

    async Task AdminUpdate()
    {
        if (_adminBusy) return;
        _adminBusy = true; _adminMsg = "Enviando actualización…"; StateHasChanged();
        try { await Cliente.System_Update(); _adminMsg = "Comando de actualización enviado."; }
        catch (Exception ex) { _adminMsg = $"ERROR: {ex.Message}"; }
        finally { _adminBusy = false; StateHasChanged(); }
    }

    async Task AdminResetNavegador()
    {
        if (_adminBusy) return;
        _adminBusy = true; _adminMsg = "Enviando reinicio navegador…"; StateHasChanged();
        try { await Cliente.System_ResetChromium(); _adminMsg = "Comando de reinicio de navegador enviado."; }
        catch (Exception ex) { _adminMsg = $"ERROR: {ex.Message}"; }
        finally { _adminBusy = false; StateHasChanged(); }
    }

    void AdminBack()
    {
        _screen = _errorCode == LockerErrorCode.None
            ? Screen.Select
            : Screen.FueraServicio;
    }



    // lo de conexion:
    private async Task InitializeStatusAsync()
    {
        try
        {
            try
            {
                var estadoCerraduras = await Cliente.GetEstadoCerraduras();
                _cerradurasConectadas = string.Equals(
                    estadoCerraduras,
                    "Conectadas",
                    StringComparison.OrdinalIgnoreCase);
            }
            catch
            {
                _cerradurasConectadas = true;
            }

            try
            {
                var nets = await Cliente.System_GetIP();
                if (nets != null)
                {
                    var ipsFiltered = nets
                        .Where(n => n != null && !n.IP.EndsWith(".2.3"))
                        .ToArray();

                    _ethernetOk = ipsFiltered.Length > 0;
                }
            }
            catch
            {
                _ethernetOk = true;
            }

            try
            {
                _serverOk = await Cliente.PingServer();
            }
            catch
            {
                _serverOk = false;
            }

            _internetOk = _serverOk;

            RecalculateErrorCode();
        }
        catch
        {
            _errorCode = LockerErrorCode.Inesperado;
            _screen = Screen.FueraServicio;
        }
    }


    private void OnStatusChanged(string status)
    {
        try
        {
            switch (status)
            {
                case "Desconexion de red":
                    _ethernetOk = false;
                    break;

                case "Desconexion del servidor":
                    _serverOk = false;
                    break;

                case "Desconexion de internet":
                    _internetOk = false;
                    break;

                case "Conexion al servidor":
                    _serverOk = true;
                    _ethernetOk = true;
                    _internetOk = true;
                    break;

                default:
                    _errorCode = LockerErrorCode.Inesperado;
                    _screen = Screen.FueraServicio;
                    InvokeAsync(StateHasChanged);
                    return;
            }

            RecalculateErrorCode();
            InvokeAsync(StateHasChanged);
        }
        catch
        {
            _errorCode = LockerErrorCode.Inesperado;
            _screen = Screen.FueraServicio;
            InvokeAsync(StateHasChanged);
        }
    }

    private void OnCerradurasChanged(string estado)
    {
        _cerradurasConectadas = string.Equals(estado, "Conectadas",
            StringComparison.OrdinalIgnoreCase);

        RecalculateErrorCode();
        InvokeAsync(StateHasChanged);
    }

    private void RecalculateErrorCode()
    {
        LockerErrorCode nuevo;

        // 05: cerraduras + cualquier error de red/servidor/internet
        if (!_cerradurasConectadas && (!_ethernetOk || !_serverOk || !_internetOk))
            nuevo = LockerErrorCode.CerradurasYInternet;
        else if (!_cerradurasConectadas)
            nuevo = LockerErrorCode.Cerraduras;      // 01
        else if (!_serverOk)
            nuevo = LockerErrorCode.Servidor;        // 02
        else if (!_ethernetOk)
            nuevo = LockerErrorCode.RedEthernet;     // 03
        else if (!_internetOk)
            nuevo = LockerErrorCode.Internet;        // 04
        else
            nuevo = LockerErrorCode.None;

        _errorCode = nuevo;

        // Si hay error: siempre vamos a FueraServicio.
        // Si se recupera: si estábamos en FueraServicio volvemos a Select.
        if (_errorCode == LockerErrorCode.None)
        {
            if (_screen == Screen.FueraServicio)
                _screen = Screen.Select;
        }
        else
        {
            _screen = Screen.FueraServicio;
        }
    }

    private string GetErrorCodeNumber() => _errorCode switch
    {
        LockerErrorCode.Cerraduras => "01",
        LockerErrorCode.Servidor => "02",
        LockerErrorCode.RedEthernet => "03",
        LockerErrorCode.Internet => "04",
        LockerErrorCode.CerradurasYInternet => "05",
        LockerErrorCode.Inesperado => "99",
        _ => ""
    };

    private string GetErrorCodeDescription() => _errorCode switch
    {
        LockerErrorCode.Cerraduras => "Error de conexión con controladora de cerraduras.",
        LockerErrorCode.Servidor => "Error de conexión al servidor.",
        LockerErrorCode.RedEthernet => "Error de conexión de red ethernet.",
        LockerErrorCode.Internet => "Error de conexión a internet.",
        LockerErrorCode.CerradurasYInternet => "Error de conexión de cerraduras y de internet.",
        LockerErrorCode.Inesperado => "Error inesperado.",
        _ => ""
    };


    // --- dispose ---
    public async ValueTask DisposeAsync()
    {
        try { if (_scannerModule != null) await _scannerModule.InvokeVoidAsync("detach"); } catch { }
        _selfRef?.Dispose();

        try { if (_hub != null) { await _hub.StopAsync(); await _hub.DisposeAsync(); } } catch { }
        try { if (QRhubConnection != null) { await QRhubConnection.StopAsync(); await QRhubConnection.DisposeAsync(); } } catch { }
        try { if (_statusHub != null) { await _statusHub.StopAsync(); await _statusHub.DisposeAsync(); } } catch { }
        try { _countdownCts?.Cancel(); } catch { }
        try { _puertasAbiertasCts?.Cancel(); } catch { }
    }
}
