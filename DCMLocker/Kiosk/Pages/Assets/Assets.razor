@page "/assets"

@implements IAsyncDisposable

@inject IJSRuntime JS
@inject NavigationManager Nav
@inject DCMLocker.Kiosk.Cliente.TLockerCliente Cliente

<div class="container vh-100 d-flex flex-column justify-content-center">

    <!-- Encabezado común -->
    <div class="text-center mb-4">
        <h1 class="mb-1">Acerque su tarjeta</h1>
        <p class="text-muted m-0">Escanee su RFID y seleccione acción</p>
    </div>

    @if (_screen == Screen.Select)
    {
        <!-- RFID leído (si hay) -->
        <div class="text-center mb-4">
            @if (!string.IsNullOrEmpty(_rfid))
            {
                <div style="font-size:48px;line-height:1;word-break:break-all;">@_rfid</div>
                <div class="text-muted mt-2">Leído @(_readAt.ToString("HH:mm:ss"))</div>
            }
            else
            {
                <div class="text-muted">Esperando lectura…</div>
            }
        </div>

        <!-- Cards de acción (BS4) -->
        <div class="row justify-content-center">
            <div class="col-sm-6 col-md-5 col-lg-4 mb-3">
                <div class="card shadow-sm @CardBorder(AssetsAccion.Retiro)" style="cursor:pointer"
                     @onclick="() => SelectAccion(AssetsAccion.Retiro)">
                    <div class="card-body text-center">
                        <h4 class="card-title mb-0">Retiro</h4>
                    </div>
                </div>
            </div>

            <div class="col-sm-6 col-md-5 col-lg-4 mb-3">
                <div class="card shadow-sm @CardBorder(AssetsAccion.Devolucion)" style="cursor:pointer"
                     @onclick="() => SelectAccion(AssetsAccion.Devolucion)">
                    <div class="card-body text-center">
                        <h4 class="card-title mb-0">Devolución</h4>
                    </div>
                </div>
            </div>
        </div>
    }
    else if (_screen == Screen.Loading)
    {
        <div class="d-flex flex-column align-items-center justify-content-center">
            <div class="spinner-border text-primary mb-3" role="status">
                <span class="sr-only">Cargando...</span>
            </div>
            <div class="text-muted">Enviando solicitud…</div>
        </div>
    }
    else if (_screen == Screen.Result)
    {
        <div class="mb-3">
            <h4>Respuesta del servidor</h4>
            <pre class="bg-light p-3 rounded" style="white-space:pre-wrap; word-break:break-word;">@_resultRaw</pre>
        </div>

        <div class="mb-2 text-muted">Volviendo en @_countdown s…</div>
        <div class="progress mb-3" style="height: 12px;">
            <div class="progress-bar" role="progressbar" style="width:@PercentDone()%"></div>
        </div>

        <button class="btn btn-outline-secondary btn-sm" @onclick="Reset">Volver ahora</button>
    }
</div>

@code {
    // -------- Pantallas / estado --------
    enum Screen { Select, Loading, Result }
    Screen _screen = Screen.Select;

    private string? _rfid;
    private AssetsAccion? _accion;

    private DateTime _readAt;
    private string _resultRaw = "";
    private int _countdown = 20;
    private const int _resultSeconds = 20;
    private CancellationTokenSource? _countdownCts;
    private bool _sending;

    // -------- Infra: JS + Hub --------
    private IJSObjectReference? _scannerModule;
    private DotNetObjectReference<Assets>? _selfRef;
    private HubConnection? _hub;

    protected override async Task OnInitializedAsync()
    {
        _hub = new HubConnectionBuilder()
            .WithUrl(Nav.ToAbsoluteUri("/RFIDReaderHub"))
            .WithAutomaticReconnect()
            .Build();

        // Recibir lecturas de OTRAS pestañas/equipos
        _hub.On<string>("ReceiveRFID", token =>
        {
            SetRfid(token);
        });

        await _hub.StartAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        _scannerModule = await JS.InvokeAsync<IJSObjectReference>("import", "./js/LectorRFID.js");
        _selfRef = DotNetObjectReference.Create(this);

        await _scannerModule.InvokeVoidAsync("attach", _selfRef, new { acceptTabAsEnter = true });
    }

    [JSInvokable]
    public async Task OnScanEnter(string text)
    {
        // Local
        SetRfid(text);

        // Broadcast (a otras /assets)
        if (_hub is not null && _hub.State == HubConnectionState.Connected)
            await _hub.SendAsync("SendToken", text);
    }

    private void SetRfid(string token)
    {
        _rfid = token;
        _readAt = DateTime.Now;

        // si ya hay acción, avanzamos
        _ = TryProceedAsync();
        StateHasChanged();
    }

    // -------- UI helpers --------
    string CardBorder(AssetsAccion card) =>
        _accion == card ? "border-primary" : "border-secondary";

    void SelectAccion(AssetsAccion a)
    {
        // selección única; si clickean la misma, queda seleccionada
        _accion = a;
        _ = TryProceedAsync();
        StateHasChanged();
    }

    async Task TryProceedAsync()
    {
        if (_sending) return;
        
        if (string.IsNullOrWhiteSpace(_rfid) || _accion is null) return; // esta maravilla corta si falta alguno osea manda apenas esten los dos

        _sending = true;
        _screen = Screen.Loading;
        StateHasChanged();

        try
        {
            var req = new AssetsRequest { IdEmpleado = _rfid!, Accion = _accion.Value };

            // llamada al backend
            var resp = await Cliente.SendRequest(req);

            // mostrar "tal cual": si no es string, serialize
            _resultRaw = resp.ToString();

            _screen = Screen.Result;

            // countdown para volver
            _countdownCts?.Cancel();
            _countdownCts = new CancellationTokenSource();
            _ = StartCountdownAsync(_resultSeconds, _countdownCts.Token);
        }
        catch (Exception ex)
        {
            _resultRaw = $"ERROR: {ex.Message}";
            _screen = Screen.Result;
            _countdownCts?.Cancel();
            _countdownCts = new CancellationTokenSource();
            _ = StartCountdownAsync(_resultSeconds, _countdownCts.Token);
        }
        finally
        {
            _sending = false;
            StateHasChanged();
        }
    }

    async Task StartCountdownAsync(int seconds, CancellationToken token)
    {
        _countdown = seconds;
        StateHasChanged();

        while (_countdown > 0 && !token.IsCancellationRequested)
        {
            try { await Task.Delay(1000, token); } catch { break; }
            _countdown--;
            await InvokeAsync(StateHasChanged);
        }
        if (!token.IsCancellationRequested)
            Reset();
    }

    void Reset()
    {
        _countdownCts?.Cancel();

        _rfid = null;
        _accion = null;
        _resultRaw = "";
        _screen = Screen.Select;
        StateHasChanged();
    }

    string PercentDone()
    {
        var done = (_resultSeconds - _countdown) * 100 / Math.Max(1, _resultSeconds);
        return $"{done}%";
    }

    public async ValueTask DisposeAsync()
    {
        try { if (_scannerModule != null) await _scannerModule.InvokeVoidAsync("detach"); } catch { }
        _selfRef?.Dispose();
        try { if (_hub != null) { await _hub.StopAsync(); await _hub.DisposeAsync(); } } catch { }
        try { _countdownCts?.Cancel(); } catch { }
    }
}
